# 数据结构与算法

​		外修语言，内修算法，数据结构+算法是一个程序运行的保障，数据结构指的是数据的组成方式，如数组、数和链表等。数据结构可以分为线性数据结构和非线性数据结构，线性结构的特点是数据元素之间存在一一对应的关系，存储方式可以分为顺序表和链表，两者最大的不同在于存储的地址是否连续，典型的线性结构为<u>数组、链表、队列和栈</u>。非线性结构的特点是数据元素之间不存在一一对应的关系，典型的非线性结构有<u>二维数组、多维数组、广义表和数结构</u>

## 一、数组

### 1、稀疏数组

​		若一个二维数组中的元素存在很多0值或者无效值，可以将这个二维数组压缩为稀疏数组（去除0值和无效值）。可以应用在底图、棋盘等二维场景中。

![](数据结构与算法.assets/稀疏数组.PNG)

1.1二维数组转稀疏数组

①遍历原始的二维数组，得到有效的数据个数sum

②构造稀疏数组，第一行原始数组的行、列和有效数据的个数，其余行为有效值的行列坐标和存储的值

```java
sparseArr[sum+1][3]
```

1.2稀疏数组转二维数组

①取出稀疏数组的第一行，构造二维数组

②取出稀疏数组的其余行，为对应的二维数组赋值。

### 2、队列（数组实现）

队列如同现实中的排队一样，它的特点是先入先出，是一种有序列表，可有由数组或者是链表构成。

2.1数组模拟队列

![image-20191130124418217](数据结构与算法.assets/image-20191130124418217.png)

队列的输入输出分别队列的后、前端。对应的处理方法为加入数据和输出数据。(其前提是插入元素的个数要小于数组容量的个数，否则会发生越界错误，<u>因为tail是指向队尾的后一个位置</u>)

* 构造队列
* 判断队列是否为空 head !=tail
* 队列是否满 tail !=maxSize
* 加入队列   (先加入，后tail++)
* 退出队列 

对用的属性为maxSize、head（队头）、tail（队尾的后一个元素位置）

2.2环形队列

基本数组模拟队列会导致数组不能复用，所以优化方法是让数组构成环形队列。

![image-20191130143216719](数据结构与算法.assets/image-20191130143216719.png)

环形队列的基本思想是首尾相连。

* 构造队列

* 判断队列是否有空位置   head！=tail

* 判断队列是否满 (tail+1)%maxSize==head

* 加入队列，更新队头(tail+1)%maxSize

* 退出队列，更新队尾(head+1)%maxSize

* 队列长度（tail+maxSize-head）%maxSize

* 队列的索引变为 ：

  ```java
  for(i=head;i<head+(tail+maxSize-head)%maxSize;i++){
      System.out.println(arr[i%maxSize])
  }
  ```

## 二、链表(Linked List)

链表是以节点（node）存储的链式存储结构，一个node包含一个data域（存放数据）和一个next域（存放下一个node的指针），链表的各个节点不一定是连续的，它可以分为带头结点和不带头结点。头结点仅包含next域。

### 1、单向链表

1.1顺序插入

* 创建节点类，包含了data和next，next指向下一个节点对象

  >```java
  > class PersonNode {
  >    public int number;
  >    public String name;
  >    public String nickName;
  >    public PersonNode next;
  >
  >    public PersonNode(int number, String name, String nickName) {
  >        this.number = number;
  >        this.name = name;
  >        this.nickName = nickName;
  >    }
  >
  >    @Override
  >    public String toString() {
  >        return "PersonNode{" +
  >                "number=" + number +
  >                ", name='" + name + '\'' +
  >                ", nickName='" + nickName + '\'' +
  >                '}';
  >    }
  >}
  >```

* 创建单向链表类，里面包含了<u>增删改查的方法</u>

* 在链表类创建head Node，头节点的next指向第一个节点

* 实现增删改查的方法

![image-20191201182826935](数据结构与算法.assets/image-20191201182826935.png)

* 在链表中增加一个节点

> 确定要插入的节点位置，循环遍历到该位置节点的上一个节点。	
>
> ```C
> S->next=P->next
> P->next=S
> ```

* 在链表中删除一个节点

> 确定删除的位置，循环遍历到该位置节点的上一个节点
>
> ```C
> P->next=p->next->next
> ```

* 遍历链表

  ```java
   PersonNode temp = headNode;
          while (true) {
              if (temp.next == null) {
                  break;
              }
              temp = temp.next;
              System.out.println(temp);
          }
  ```

* 修改链表中的一个节点信息

> 确定要修改节点的位置，先遍历找到该节点，修改该节点的信息。

### 2、双向链表

双向链表是在单向链表的基础上加入pre指针，因此支持双向的增删改查。

>```java
> 	public int number;
>    public String name;
>    public String nickName;
>    public PersonNode next;
>    public PersonNode pre;
>```

* 双向链表的遍历

>双向链表的遍历与单向链表相同，可以按照两个方向遍历。

* 双向链表的添加

>1、在末尾添加
>
>![](数据结构与算法.assets/双向链表的末尾添加-1577283213037.PNG)
>
>在双向链表的末尾添加C节点（定位到节点B）
>
>```java
>B->next=C
>C->pre=B
>```
>
>2、在两节点间添加
>
>![](数据结构与算法.assets/双向链表中间添加.PNG)
>
>在节点B和节点C间添加D（程序定位到节点D），
>
>顺序：**先搞定D的前驱和后继节点，再搞定C的节点的前驱和B的后继节点。**
>
>```java
>D->pre=B
>D->next=C
>C->pre=D
>B->next=D
>```

* 双向链表的修改

>同单链表修改相同

* 双向链表的删除

>1、在链表尾部删除（定位到节点P（B））
>
>![](数据结构与算法.assets/双向链表末尾删除.PNG)
>
>2、在两节点间删除（定位到节点S（D））
>
>![](数据结构与算法.assets/双向链表中间删除.PNG)

### 3、单向循环链表（无头结点）

单向循环链表是首尾相连，使整个单链表构成一个环。约瑟夫问题时单向循环链表的一个典型的应用

约瑟夫问题描述：

>约瑟夫问题是一个非常著名的趣题，即由n个人坐成一圈，按顺时针由1开始给他们编号。* 然后由第一个人开始报数，数到m的人出局。现在需要求的是最后一个出局的人的编号。* 给定两个int n和m，代表游戏的人数。请返回最后一个出局的人的编号.

问题分析：

约瑟夫问题可以简单分为两个步骤

构造Boy节点类

```java
 private int number;
 private Boy next;
```



* 构建一个单向循环链表

>![](数据结构与算法.assets/循环链表构造.PNG)
>
>定义两个指针变量First和cur，first表示头结点，cur指向当前节点
>
>```java
>构造第一个节点first
> first = boy;//第一个节点为first
> first.setNext(first);//仅有一个节点时，first指向first，构成闭环
> cur = first;//辅助变量指向first
>构造其它节点 
>cur.setNext(boy);//将新添加的节点设置为当前节点的后继节点
>boy.setNext(first);//新添加的节点与first构成闭环
>cur=boy;//将当前节点设置为新添加的节点
>```

* 根据约定的规则退出循环链表，直至仅有一个节点

>![](数据结构与算法.assets/节点出循环链表.PNG)
>
>定义两个辅助节点变量first和helper，first指向每一轮要开始的节点，helper指向最后一个节点，当first与helper指向同一个节点时，该循环链表仅剩一个节点
>
>```java
>构造函数
>    moveCycle(int no,int number,int sum)
>1、确定从第几个节点开始
>for(int i=0;i<no-1;i++){
>            first=first.getNext();
>            helper=helper.getNext();
>        }
> 2、循环，找出节点，直至仅剩一个节点
>   while (true){
>            if(first==helper){
>                System.out.printf("最后一个节点时%d\n",first.getNumber());
>                break;
>            }
>            //开始,每number下，出圈一次
>            for(int j=0;j<number-1;j++){
>                first=first.getNext();
>                helper=helper.getNext();
>            }
>            System.out.printf("%d出圈\n",first.getNumber());
>            first=first.getNext();
>            helper.setNext(first);
>        }
>```

## 三、栈（Stack）

### 1、栈的概念

​	栈与队列相反，队列是在队头进入，队尾出队的线性表，栈是仅能在栈顶进行插入和删除的线性表(先入先出)。我们通常把允许插入和删除的一端成为栈顶，另一端称为栈底。栈的插入操作为入栈，栈的删除操作为出栈，不含任何数据元素的栈称为空栈。

![](数据结构与算法.assets/进栈图.PNG)

栈的表示：

* 用数组模拟栈
* 用链表模拟栈

### 2、栈的应用场景

前缀、中缀和后缀表达式

* 前缀表达式是运算符在前，数字符在后

> (3+4)*5-6  ====>  - * + 3 4 5 6

* 中缀表达式，我们通常书写的表达式的形式

>(3+4)*5-6  

* 后缀表达式，数字符在前，运算符在后

> (3+4)*5-6 =====>3 4 + 5 * 6

中缀表达式转后缀表达式

* 初始化两个栈，运算符栈s1和存储中间结果的栈s2（也可用list来表示）；
* 从左到右扫描中缀表达式
* 遇到操作数时，将其压入s2，
* 遇到运算符时，比较其与栈顶元素符的优先级：

>* 如果s1为空，或栈顶符号为左括号“（ ”，则直接将运算符入栈
>* 否则，若优先级比栈顶优先级高，将运算符压入栈s1
>* 否则，将s1栈顶的运算符弹出并压入到s2中，转到第四步继续循环

* 遇到括号时：

>如果是左括号“（ ”，直接压入s1
>
>如果是右括号“ ）”，则依次弹出s1栈顶运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃。	

* 重复上述步骤，直至表达式的最右边
* 将s1中的剩余运算符依次弹出并压入s2
* 依次弹出s2中的元素并输出，结果的逆序为中缀表达式对应的后缀表达式。

#### 2.1 四则表达式的运算（模拟计算器）

![](数据结构与算法.assets/栈在四则运算中的应用.PNG)

* 采用中缀表达式的方式计算，中缀表达式为“7+2*6-4”传统形式的表达式。

>1、通过一个index索引查找表达式的符号
>
>2、若当前指向的符号为数字，就放入数字栈中，若是符号就放入符号栈中
>
>3、当index指向运算符时，若此时符号栈为空，直接入栈，若符号栈不为空，则比较index指向的符号与栈顶的符号的优先级，若index指向的运算符大于等于栈顶的运算符时，将index指向的运算符入栈，否则将数字栈中前两位运算符（num1、num2）出栈，符号栈中的栈顶指向的运算符出栈，运算后**(num2运算符num1)**放入数字栈中。
>
>4、当表达式扫描完毕，就顺序的从数字栈和符号栈中pop出相应的数字和符号进行运算。
>
>5、当数字栈中仅有一个元素时，就是表达式的值。

* 采用后缀表达式计算 9 3 1 -3 * +10 2 / +

>1、通过一个index索引查找表达式的符号
>
>2、若当前指向的符号为数字，就放入数字栈中，若是符号，就将处于栈顶的里两个数字出栈，并进行运算
>
>3、将结算结果进栈，一直到最终获得结果。

#### 2.2、递归

递归（recursion）是指通过重复将问题分解为同类的子问题而解决问题的方法。简单来说，递归就是自己调用自己。

递归需要遵守的规则：

>1、执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
>
>2、方法的局部变量是独立的，不会互相影响
>
>3、如果方法中使用的是引用类型的变量（比如数组），就会共享该引用类型的数据。
>
>4、递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverFlowError
>
>5、当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

例子：

![](数据结构与算法.assets/递归栈.PNG)

```java
 public static  void getValue(int value){
        if(value>2){
            getValue(value-1);
        }
        System.out.println("the value is "+value);

    }
```

递归的的经典算法

* 迷宫

  描述：有一个迷宫地图，有一些可达的位置，也有一些不可达的位置（障碍、墙壁、边界）* 。从一个位置到下一个位置只能通过向上（或者向右、或者向下、或者向左）走一步来实现，从起点出发，如何找到一条到达终点的通路。

  分析：

>```java
>定义一个二维数组，1表示位置不可到达，2表示通路可以走，3表示位置已经走过，走不通，0表示还未走过的点
> * 采用递归的算法
> * 1、map表示地图
> * 2、i,j表示从地图的那个位置开始出发（1,1）
> * 3、如果小球到map[i][j](终点)位置，则说明通路找到
> * 4、策略：下->右->上->左（算法的优化是策略的变化）
>```

* 八皇后问题

  描述：在一个8*8的国际象棋上摆放八个皇后，使其不能相互攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，共有多少种摆法？

  分析：

>```java
>1、第一个皇后放在第一行第一列
>2、第二个皇后放在第二行第一列，然后判断是否Ok，如果不Ok，继续放在第二列、第三列，依次把所有列都放完，找到一个合适的
>3、继续放第三个皇后，继续放第一列、第二列，.......直到第8个皇后放在一个不冲突的位置，这就算找到了一个正确解
>4、当找到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一皇后放到第一列的所有正确解，全部得到
>5、然后回头继续第一个皇后放第二列，后面继续执行1,2,3,4步骤
>说明：
>    使用一个1维数组来表示，arr[8]={0,4,7,5,2,6,1,3}，下标对应第几行，arr[i]=value,value表示第i+1个皇后放在第i+1列。
>```





